package com.ossia.test.app;

import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.ossia.test.domain.Niveau;
import com.ossia.test.domain.Profil;
import com.ossia.test.domain.PropositionReponse;
import com.ossia.test.domain.Question;
import com.ossia.test.domain.TestSheet;
import com.ossia.test.service.ProfilService;
import com.ossia.test.service.TestSheetService;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"classpath*:/META-INF/config/applicationContext-*.xml"})
public class AjoutAllTestsEncoded {

	private final Log log = LogFactory.getLog(getClass()) ;

	@Autowired
    private TestSheetService testSheetService ; 

	@Autowired
    private ProfilService profilService ; 

	private TestSheet createTestJava () {
        TestSheet testJava = new TestSheet() ;
        testJava.setDuree(90);
        testJava.setIntitule("Java test");
        testJava.setAdditionalInfo("Each question can have several answers, don't forget it." + "\n" +
        		"Please considere that JDK 6 is used for each question.") ; 
        testJava.setType("JAVA");
        
        Map <Question , Map <String , Boolean>> mapQuestions = questionsJava() ; 
        fillAllQuestions(testJava, mapQuestions) ; 
        
        return testJava ; 
    }
	
	private Map<Question, Map<String, Boolean>> questionsJava () {
		
		Map <Question , Map <String , Boolean>> mapQuestions = new LinkedHashMap <Question , Map <String , Boolean>>() ; 
		Map <String , Boolean> mapPropositions = new LinkedHashMap <String , Boolean> () ; 
		
		Question question = new Question("Java Core", "Which are true concerning collections extended the Set interface:", Niveau.INTERMEDIAIRE) ; 
		mapPropositions.put("Unordered when we iterate on", Boolean.TRUE) ;
		mapPropositions.put("Ordered when we iterate on", Boolean.FALSE) ; 
		mapPropositions.put("Indexed", Boolean.FALSE) ; 
		mapPropositions.put("Can contain duplicate values", Boolean.FALSE) ; 
		mapPropositions.put("Cannot contain duplicate values", Boolean.TRUE) ; 
		mapPropositions.put("Couldn't contain object that redefines hashcode() method", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ; 
		
		question = new Question("Java Core", "A non-inner class can be:", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("final", Boolean.TRUE) ; 
		mapPropositions.put("static", Boolean.FALSE) ; 
		mapPropositions.put("protected", Boolean.FALSE) ; 
		mapPropositions.put("public", Boolean.TRUE) ; 
		mapPropositions.put("private", Boolean.FALSE) ; 
		mapPropositions.put("volatile", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Java Core", 
				"Considering the method [NL][code style=java]protected  Object calc(){[NL][TAB]return new String([DB]toto[DB]);[NL]}[/code][NL]Admit there is a subclass that inherits this method. Which methods is a good override of it?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("[code style=java][NL]protected Object calc() {\n\treturn this;\n}\n[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=java][NL]private Object calc() {\n\treturn this;\n}\n[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=java][NL]public Object calc() {\n\treturn this;\n}\n[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=java][NL]Object calc() {\n\treturn this;\n}\n[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=java][NL]public String calc() {\n\treturn new String([DB]toto[DB]);\n}\n[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=java][NL]protected Object calc(int i) {\n\treturn this;\n}\n[/code]", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Java Core", "For avoiding surprises in remote access with RMI, the attribute SerialVersionUID in Java Bean must be :", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Generated by the compiler itself.", Boolean.FALSE) ; 
		mapPropositions.put("Hard-Coded by the user himself and incremented when the Java Bean change one of its attributes always by himself.", Boolean.TRUE) ; 
		mapPropositions.put("It's not matter to care about this attribute.", Boolean.FALSE) ; 
		mapPropositions.put("None of these answers.", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Java Core", "Which are true?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("A runtime exception is a checked exception.", Boolean.FALSE) ; 
		mapPropositions.put("A runtime exception is an unchecked exception.", Boolean.TRUE) ; 
		mapPropositions.put("We must declare a checked exception in the declaration of a method if this one throws one and doesn't catch it.", Boolean.TRUE) ; 
		mapPropositions.put("A checked exception should extend RuntimeException.", Boolean.FALSE) ; 
		mapPropositions.put("A potential ArithmeticException in code must always be catch by a try/catch block.", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Java Core", "What will be printed?[NL][NL]" + 
				"[code style=java]" +
				"class Foo {" +
				"[NL][TAB]private int x = 0;" +
				"[NL][TAB]private int y = 2;" +
				"[NL][TAB]public static void main(String[] args) {" +
				"[NL][TAB][TAB]new  Foo().calc();" +
				"[NL][TAB]}" +
				"[NL]" +
				"[NL][TAB]public void calc(){" +
				"[NL][TAB][TAB]try {" +
				"[NL][TAB][TAB][TAB]int w = x/y;" +
				"[NL][TAB][TAB][TAB]System.out.println([DB]House[DB]);" +
				"[NL][TAB][TAB][TAB]int z = y/x;" +
				"[NL][TAB][TAB][TAB]System.out.println([DB]Bar[DB]);" +
				"[NL][TAB][TAB]}" +
				"[NL][TAB][TAB]catch(ArithmeticException e){" +
				"[NL][TAB][TAB][TAB]return;" +
				"[NL][TAB][TAB]}" +
				"[NL][TAB][TAB]finally{" +
				"[NL][TAB][TAB][TAB]System.out.println([DB]Hello[DB]);" +
				"[NL][TAB][TAB]}" +
				"[NL][TAB]}" +
				"[NL]}" +
				"[/code]", 
				Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Nothing", Boolean.FALSE) ; 
		mapPropositions.put("House (only because there is a [DB]return[DB] in the catch block).", Boolean.FALSE) ; 
		mapPropositions.put("House [NL]Bar", Boolean.FALSE) ; 
		mapPropositions.put("Hello [NL]House [NL]Bar", Boolean.FALSE) ; 
		mapPropositions.put("House [NL]Hello", Boolean.TRUE) ; 
		mapPropositions.put("Hello", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Java core", "Which is true?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("[DB]X extends Y[DB] is correct if and only if X is a class and Y is an interface", Boolean.FALSE) ; 
		mapPropositions.put("[DB]X extends Y[DB] is correct if and only if X is an interface and Y is a class", Boolean.FALSE) ; 
		mapPropositions.put("[DB]X extends Y[DB] is correct if X and Y are either both classes or both interfaces", Boolean.TRUE) ; 
		mapPropositions.put("[DB]X extends Y[DB] is correct for all combinations of X and Y being classes and/or interfaces", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		StringBuilder string = new StringBuilder() ; 
		string.append("Given the code below [NL]") ; 
		string.append("[code style=java]") ;
		string.append("class CardBoard {") ;
		string.append("[NL][TAB]").append("Short story = 200;") ;
		string.append("[NL][TAB]").append("CardBoard go(CardBoard cb) {") ;
		string.append("[NL][TAB][TAB]").append("cb = null;") ;
		string.append("[NL][TAB][TAB]").append("return cb;") ;
		string.append("[NL][TAB]").append("}") ;
		string.append("[NL][TAB]").append("public static void main(String[] args) {") ;
		string.append("[NL][TAB][TAB]").append("CardBoard c1 = new CardBoard();") ;
		string.append("[NL][TAB][TAB]").append("CardBoard c2 = new CardBoard();") ;
		string.append("[NL][TAB][TAB]").append("CardBoard c3 = c1.go(c2);") ;
		string.append("[NL][TAB][TAB]").append("c1 = null;") ;
		string.append("[NL][TAB][TAB]").append("// do Stuff") ;
		string.append("[NL][TAB]").append("}").append("[NL]").append("}") ;
		string.append("[/code]") ;
		question = new Question("Java Core", string.toString() + "[NL]When // do Stuff is reached, how many objects are eligible for GC?" , Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("0", Boolean.FALSE) ; 
		mapPropositions.put("1", Boolean.FALSE) ; 
		mapPropositions.put("2", Boolean.TRUE) ; 
		mapPropositions.put("Compilation fails", Boolean.FALSE) ; 
		mapPropositions.put("It is not possible to know", Boolean.FALSE) ; 
		mapPropositions.put("An exception is thrown at runtime", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("Given the code below [NL]") ; 
		string.append("[code style=java]") ;
		string.append("public class Electronic implements Device {") ;
		string.append("[NL][TAB]public void doIt() { }[NL]}") ;
		string.append("[NL][NL]").append("abstract class Phone1 extends Electronic { }") ;
		string.append("[NL][NL]").append("abstract class Phone2 extends Electronic ").append("{[NL][TAB]public void doIt(int x) { }[NL]}") ;
		string.append("[NL][NL]").append("class Phone3 extends Electronic implements Device").append("{[NL][TAB]public void doStuff() { }[NL]}") ;
		string.append("[NL][NL]").append("interface Device {[NL][TAB]public void doIt();[NL]}") ;
		string.append("[/code]") ;
		question = new Question("Java core", string.toString() + "[NL]What is the result?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Compilation succeeds", Boolean.TRUE) ; 
		mapPropositions.put("Compilation fails with an error on line 1", Boolean.FALSE) ; 
		mapPropositions.put("Compilation fails with an error on line 5", Boolean.FALSE) ; 
		mapPropositions.put("Compilation fails with an error on line 7", Boolean.FALSE) ; 
		mapPropositions.put("Compilation fails with an error on line 11", Boolean.FALSE) ; 
		mapPropositions.put("Compilation fails with an error on line 15", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;

		string = new StringBuilder() ; 
		string.append("Given the following [NL]") ; 
		string.append("[code style=java]") ;
		string.append("class X {[NL][TAB]void do1() { }[NL]}[NL]") ; 
		string.append("[NL]").append("class Y extends X {[NL][TAB]void do2() { }[NL]}[NL]") ;
		string.append("[NL]").append("class Chrome {") ;
		string.append("[NL][TAB]").append("public static void main(String [] args) {")  ;
		string.append("[NL][TAB][TAB]").append("X x1 = new X();") ;
		string.append("[NL][TAB][TAB]").append("X x2 = new Y();") ;
		string.append("[NL][TAB][TAB]").append("Y y1 = new Y();") ;
		string.append("[NL][TAB][TAB]").append("// insert code here") ;
		string.append("[NL][TAB]").append("}").append("[NL]").append("}") ;
		string.append("[/code]") ;
		question = new Question("Java core", string.toString() + "[NL]Which inserted at line 14 will compile?" , Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("[code style=java]x2.do2();[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=java](Y)x2.do2();[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=java]((Y)x2).do2();[/code]", Boolean.TRUE) ; 
		mapPropositions.put("None of the above statements will compile", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		question = new Question("Java core", "Which statements are true about comparing two instances of the same class, given that the equals() and hashCode() methods have been properly overridden? (Choose all that apply.)", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("If the equals() method returns true, the hashCode() comparison == might return false", Boolean.FALSE) ; 
		mapPropositions.put("If the equals() method returns false, the hashCode() comparison == might return true", Boolean.TRUE) ; 
		mapPropositions.put("If the hashCode() comparison == returns true, the equals() method must return true", Boolean.FALSE) ; 
		mapPropositions.put("If the hashCode() comparison == returns true, the equals() method might return true", Boolean.TRUE) ;
		mapPropositions.put("If the hashCode() comparison != returns true, the equals() method might return true", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		string = new StringBuilder() ; 
		string.append("Given the following [NL]") ; 
		string.append("[code style=java]") ;
		string.append("class Fork {")
			  .append("[NL][TAB]").append("public static void main(String[] args) {") ;
		string.append("[NL][TAB][TAB]").append("if(args.length == 1 || args[192].equals([DB]test[DB])) {") ;
		string.append("[NL][TAB][TAB][TAB]").append("System.out.println([DB]test case[DB]);") ;
		string.append("[NL][TAB][TAB]").append("} else {") ;
		string.append("[NL][TAB][TAB][TAB]").append("System.out.println([DB]production [DB] + args[0]);") ;
		string.append("[NL][TAB][TAB]").append("}") ;
		string.append("[NL][TAB]").append("}") ;
		string.append("[NL]").append("}") ;
		string.append("[/code]") ;
		question = new Question("Java core", string.toString() + "[NL]With the command-line invocation : java Fork live2, what is the result?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("test case", Boolean.TRUE) ; 
		mapPropositions.put("production live2", Boolean.FALSE) ; 
		mapPropositions.put("test case live2", Boolean.FALSE) ; 
		mapPropositions.put("Compilation fails", Boolean.FALSE) ;
		mapPropositions.put("An exception is thrown at runtime", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		question = new Question("Java Core", "Which are true? ", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("The notifyAll() method must be called from a synchronized context", Boolean.TRUE) ; 
		mapPropositions.put("To call wait(), an object must own the lock on the thread", Boolean.FALSE) ; 
		mapPropositions.put("The notify() method is defined in class java.lang.Thread", Boolean.FALSE) ; 
		mapPropositions.put("When a thread is waiting as a result of wait(), it release its lock", Boolean.TRUE) ;
		mapPropositions.put("The notify() method causes a thread to immediately release its lock", Boolean.FALSE) ; 
		mapPropositions.put("The difference between notify() and notifyAll() is that notifyAll() notifies all waiting threads, regardless of the object they're waiting on", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		string = new StringBuilder() ; 
		string.append("Given the following [NL]") ; 
		string.append("[code style=java]") ;
		string.append("import java.util.*;").append("") ;
		string.append("[NL][NL]").append("class Business { }") ;
		string.append("[NL][NL]").append("class Hotel extends Business { }") ;
		string.append("[NL][NL]").append("class Inn extends Hotel { }") ;
		string.append("[NL][NL]").append("public class Travel {") ; 
		string.append("[NL][TAB]").append("ArrayList<Hotel> go() {") ;
		string.append("[NL][TAB]").append("// insert code here") ;
		string.append("[NL][TAB]").append("}").append("[NL]").append("}") ;
		string.append("[/code]") ;
		question = new Question("Java Core", string.toString() + "[NL]Which, inserted independently at line 11, will compile?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("[code style=java]" + "return new ArrayList<Inn>();" + "[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=java]" + "return new ArrayList<Hotel>();" + "[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=java]" + "return new ArrayList<Object>();" + "[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=java]" + "return new ArrayList<Business>();" + "[/code]", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		string = new StringBuilder() ; 
		string.append("The following block of code creates a Thread using a Runnable target").append("[NL]") ; 
		string.append("[code style=java]") ;
		string.append("Runnable target = new MyRunnable();").append("[NL]") ;
		string.append("Thread myThread = new Thread(target);").append("[NL]") ;
		string.append("[/code]") ;
		question = new Question("Java Core", string.toString() + "[NL]Which of the following classes can be used to create the target, so that the preceding code compiles correctly?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("[code style=java]" + "public class MyRunnable extends Runnable {[NL][TAB]public void run() {}[NL]}" + "[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=java]" + "public class MyRunnable extends Object {[NL][TAB]public void run() {}[NL]}" + "[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=java]" + "public class MyRunnable implements Runnable {[NL][TAB]public void run() {}[NL]}" + "[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=java]" + "public class MyRunnable implements Runnable {[NL][TAB]void run() {}[NL]}" + "[/code]", Boolean.FALSE) ;
		mapPropositions.put("[code style=java]" + "public class MyRunnable implements Runnable {[NL][TAB]public void start() {}[NL]}" + "[/code]", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		string = new StringBuilder() ; 
		string.append("[code style=java]") ;
		string.append("public class Navel {").append("") ;
		string.append("[NL][TAB]").append("private int size = 7;") ;
		string.append("[NL][TAB]").append("private static int length = 3;") ;
		string.append("[NL][TAB]").append("public static void main(String[] args) {") ;
		string.append("[NL][TAB][TAB]").append("new Navel().go();") ;
		string.append("[NL][TAB]").append("}") ;
		string.append("[NL][TAB]").append("void go() {") ;
		string.append("[NL][TAB][TAB]").append("int size = 5;") ;
		string.append("[NL][TAB][TAB]").append("System.out.println(new Gazer().adder());") ;
		string.append("[NL][TAB]").append("}") ;
		string.append("[NL][TAB]").append("class Gazer {") ;
		string.append("[NL][TAB][TAB]").append("int adder() { return size * length; }") ;
		string.append("[NL][TAB]").append("}").append("[NL]").append("}") ;
		string.append("[/code]") ;
		question = new Question("Java Core", "What is the result ?[NL][NL]" + string.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("15", Boolean.FALSE) ; 
		mapPropositions.put("21", Boolean.TRUE) ; 
		mapPropositions.put("An exception is thrown at runtime", Boolean.FALSE) ; 
		mapPropositions.put("Compilation fails due to multiple errors", Boolean.FALSE) ;
		mapPropositions.put("Compilation fails due only to an error on line 2", Boolean.FALSE) ;
		mapPropositions.put("Compilation fails due only to an error on line 12", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("JDBC", "Which interface allows setting the auto-commit mode to false? ", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("PreparedStatement", Boolean.FALSE) ; 
		mapPropositions.put("ResultSet", Boolean.FALSE) ; 
		mapPropositions.put("Connection", Boolean.TRUE) ; 
		mapPropositions.put("Statement", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		

		string = new StringBuilder() ; 
		string.append("[code style=sql]") ; 
		string.append("Name       Age        Address").append("") ;
		string.append("[NL]").append("-----------------------------------") ;
		string.append("[NL]").append("Mike       24         123 Four st.") ;
		string.append("[/code]") ;
		question = new Question("JDBC", "Assume a query returns the following row of information:[NL][NL]" + string.toString() +
				"[NL]With a ResultSet positioned to read from this row, which of the following methods could we use to read Mike's name ?" , Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("[code style=java]getString(0);[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=java]getString(1);[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=java]getObject([DB]Name[DB]);[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=java]getInt(1);[/code]", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		

		string = new StringBuilder() ; 
		string.append("Two messages are created and sent at the same time. ").append("[NL]") ;
		string.append("Message A has a JMSPriority of 4, whilst Message B has a JMSPriority of 7.  ").append("[NL]") ;
		string.append("[NL]").append("According to the JMS Specification, which of the following is true? ") ;
		question = new Question("Messaging", string.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Message B is likely to be delivered before Message A", Boolean.TRUE) ; 
		mapPropositions.put("Message B will certainly be delivered before Message A", Boolean.FALSE) ; 
		mapPropositions.put("Both messages are delivered at the same time", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Messaging", "The value zero for JMSExpiration header field in the JMS Message indicates that the message will never expire. ", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("True", Boolean.TRUE) ; 
		mapPropositions.put("False", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Spring", "You can read multiple bean definition files with a ClassPathXmlApplicationContext and obtain a single BeanFactory.", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("True", Boolean.TRUE) ; 
		mapPropositions.put("False", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Spring", "What will happen if the following code is executed but no bean matching that name exists in the configuration?[NL][NL]" + 
				"[code style=java]" + "Object bean1 = beanFactoryRef.getBean([DB]beanName[DB]);" + "[/code]", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("The code will not compile.", Boolean.FALSE) ; 
		mapPropositions.put("Bean1 will be null", Boolean.FALSE) ; 
		mapPropositions.put("An org.springframework.beans.factory.NoSuchBeanDefinitionException will be thrown at runtime.", Boolean.TRUE) ; 
		mapPropositions.put("An org.springframework.beans.FatalBeanException will be thrown at runtime.", Boolean.FALSE) ;
		mapPropositions.put("A reference to the bean will nevertheless be obtained.", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Spring", "Which configuration will deploy the bean as a singleton?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("[code style=xml]<bean name=[DB]name1[DB] class=[DB]ExampleBean1[DB] />[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=xml]<bean name=[DB]name2[DB] class=[DB]ExampleBean2[DB] singleton=[DB]true[DB]/>[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=xml]<bean id=[DB]name3[DB] class=[DB]ExampleBean3[DB] singleton=[DB]false[DB]/>[/code]", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("Consider the following bean class.") ;
		string.append("[code style=java]").append("package somepackage;") ;
		string.append("[NL][NL]").append("public class CoolBeanContainingAList {") ;
		string.append("[NL][TAB]").append("private List list;") ;
		string.append("[NL][TAB]").append("public void setList(List list) {") ;
		string.append("[NL][TAB][TAB]").append("this.list = list;") ;
		string.append("[NL][TAB]").append("}").append("[NL]").append("}") ; 
		string.append("[/code]");
		string.append("[NL]").append("We want to define this bean in an application context.") ;
		string.append("[NL]").append("We want to inject a list of Integers into the bean containing the values 1, 2 and 3. ").append("[NL]") ;
		question = new Question("Spring", string.toString() + "In which way(s) can this be configured?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		
		string = new StringBuilder() ; 
		string.append("[code style=xml]") ;
		string.append("<bean id=[DB]coolBean[DB] class=[DB]somepackage.CoolBeanContainingAList[DB]>") ;
		string.append("[NL][TAB]").append("<property name=[DB]list[DB]>") ;
		string.append("[NL][TAB][TAB]").append("<value>1</value>") ;
		string.append("[NL][TAB][TAB]").append("<value>2</value>") ;
		string.append("[NL][TAB][TAB]").append("<value>3</value>") ;
		string.append("[NL][TAB]").append("</property>") ;
		string.append("[NL]").append("</bean>") ;
		string.append("[/code]");
		mapPropositions.put(string.toString(), Boolean.FALSE) ; 
		
		string = new StringBuilder() ; 
		string.append("[code style=xml]") ;
		string.append("<bean id=[DB]coolBean[DB] class=[DB]somepackage.CoolBeanContainingAList[DB]>") ;
		string.append("[NL][TAB]").append("<property name=[DB]list[DB]>") ;
		string.append("[NL][TAB][TAB]").append("<list>") ;
		string.append("[NL][TAB][TAB][TAB]").append("<value>1</value>") ;
		string.append("[NL][TAB][TAB][TAB]").append("<value>2</value>") ;
		string.append("[NL][TAB][TAB][TAB]").append("<value>3</value>") ;
		string.append("[NL][TAB][TAB]").append("</list>") ;
		string.append("[NL][TAB]").append("</property>") ;
		string.append("[NL]").append("</bean>") ;
		string.append("[/code]");
		mapPropositions.put(string.toString(), Boolean.FALSE) ; 
		
		string = new StringBuilder() ; 
		string.append("[code style=xml]") ;
		string.append("<bean id=[DB]coolBean[DB] class=[DB]somepackage.CoolBeanContainingAList[DB]>") ;
		string.append("[NL][TAB]").append("<property name=[DB]list[DB]>") ;
		string.append("[NL][TAB][TAB]").append("<value>1,2,3</value>") ;
		string.append("[NL][TAB]").append("</property>") ;
		string.append("[NL]").append("</bean>") ;
		string.append("[/code]");
		mapPropositions.put(string.toString(), Boolean.FALSE) ; 
		
		string = new StringBuilder() ; 
		string.append("[code style=xml]") ;
		string.append("<bean id=[DB]coolBean[DB] class=[DB]somepackage.CoolBeanContainingAList[DB]>") ;
		string.append("[NL][TAB]").append("<property name=[DB]list[DB]>") ;
		string.append("[NL][TAB][TAB]").append("<list>") ;
		string.append("[NL][TAB][TAB][TAB]").append("<value type=[DB]java.lang.Integer[DB]>1</value>") ;
		string.append("[NL][TAB][TAB][TAB]").append("<value type=[DB]java.lang.Integer[DB]>2</value>") ;
		string.append("[NL][TAB][TAB][TAB]").append("<value type=[DB]java.lang.Integer[DB]>3</value>") ;
		string.append("[NL][TAB][TAB]").append("</list>") ;
		string.append("[NL][TAB]").append("</property>") ;
		string.append("[NL]").append("</bean>") ;
		string.append("[/code]");
		mapPropositions.put(string.toString(), Boolean.TRUE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("Given the following two classes" + "[NL]") ; 
		string.append("[code style=java]") ;
		string.append("package ar.com.car.engine;") ;
		string.append("[NL][NL]").append("public interface Engine {") ;
		string.append("[NL][TAB]").append("int getHP();") ;
		string.append("[NL]").append("}[/code]") ;
		string.append("and") ;
		string.append("[code style=java]").append("package ar.com.car;") ;
		string.append("[NL][NL]").append("public class Car {") ;
		string.append("[NL][NL][TAB]").append("private Engine engine;") ;
		string.append("[NL][TAB]").append("public void setEngine(Engine engine) {") ;
		string.append("[NL][TAB][TAB]").append("this.engine= engine;") ;
		string.append("[NL][TAB]").append("}") ;
		string.append("[NL]").append("}") ;
		string.append("[/code]");
		question = new Question("Spring", 
			string.toString() + "Select the correct way to inject a V8Engine into the car (V8Engine implements the Engine interface)", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		
		string = new StringBuilder() ; 
		string.append("[code style=xml]") ;
		string.append("<beans>") ;
		string.append("[NL][TAB]").append("<bean id=[DB]v8Engine[DB] class=[DB]ar.com.carProject.engine.V8Engine[DB]/>") ;
		string.append("[NL][TAB]").append("<bean id=[DB]car[DB] class=[DB]ar.com.car.Car[DB]>") ;
		string.append("[NL][TAB][TAB]").append("<property name=[DB]engine[DB] ref=[DB]v8Engine[DB]/>") ;
		string.append("[NL][TAB]").append("</bean>") ;
		string.append("[NL]").append("</beans>") ;
		string.append("[/code]");
		mapPropositions.put(string.toString(), Boolean.TRUE) ;
		
		string = new StringBuilder() ; 
		string.append("[code style=xml]") ;
		string.append("<beans>") ;
		string.append("[NL][TAB]").append("<bean id=[DB]v8Engine[DB] class=[DB]ar.com.carProject.engine.V8Engine[DB]/>") ;
		string.append("[NL][TAB]").append("<bean id=[DB]car[DB] class=[DB]ar.com.car.Car[DB]>") ;
		string.append("[NL][TAB][TAB]").append("<property name=[DB]engine[DB] value=[DB]v8Engine[DB]/>") ;
		string.append("[NL][TAB]").append("</bean>") ;
		string.append("[NL]").append("</beans>") ;
		string.append("[/code]");
		mapPropositions.put(string.toString(), Boolean.FALSE) ;
		
		string = new StringBuilder() ; 
		string.append("[code style=xml]") ;
		string.append("<beans>") ;
		string.append("[NL][TAB]").append("<bean id=[DB]v8Engine[DB] class=[DB]ar.com.carProject.engine.V8Engine[DB]/>") ;
		string.append("[NL][TAB]").append("<bean id=[DB]car[DB] class=[DB]ar.com.car.Car[DB]>") ;
		string.append("[NL][TAB][TAB]").append("<property name=[DB]engine[DB]>") ; 
		string.append("[NL][TAB][TAB][TAB]").append("<value>v8Engine</value>") ;
		string.append("[NL][TAB][TAB]").append("</property>") ;
		string.append("[NL][TAB]").append("</bean>") ;
		string.append("[NL]").append("</beans>") ;
		string.append("[/code]");
		mapPropositions.put(string.toString(), Boolean.FALSE) ;
		
		string = new StringBuilder() ; 
		string.append("[code style=xml]") ;
		string.append("<beans>") ;
		string.append("[NL][TAB]").append("<bean id=[DB]car[DB] class=[DB]ar.com.car.Car[DB]>") ;
		string.append("[NL][TAB][TAB]").append("<property name=[DB]engine[DB]>") ;
		string.append("[NL][TAB][TAB][TAB]").append("<bean class=[DB]ar.com.carProject.engine.V8Engine[DB]/>") ;
		string.append("[NL][TAB][TAB]").append("</property>") ;
		string.append("[NL][TAB]").append("</bean>") ;
		string.append("[NL]").append("</beans>") ;
		string.append("[/code]");
		mapPropositions.put(string.toString(), Boolean.TRUE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		/* ------ */
		string = new StringBuilder() ; 
		string.append("Suppose we have a default interceptor defined in the deployment descriptor. If we want to disable that default interceptor for a class, we can annotate that class with @ExcludeDefaultInterceptors.") ;
		question = new Question("EJB", string.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("True", Boolean.TRUE) ; 
		mapPropositions.put("False", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("Suppose we have an EJB class. Providing settings through the deployment descriptor will override the ones set through annotations (if any).") ;
		question = new Question("EJB", string.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("True", Boolean.TRUE) ; 
		mapPropositions.put("False", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("Select candidates for instance pooling:") ;
		question = new Question("EJB", string.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Stateless session beans", Boolean.TRUE) ; 
		mapPropositions.put("Stateful session beans", Boolean.FALSE) ;
		mapPropositions.put("Message-driven beans", Boolean.TRUE) ; 
		mapPropositions.put("Entity beans", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("Which of the following statements about EJB 3.0 interceptors mechanism are true?") ;
		question = new Question("EJB", string.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Interceptors can be specified at the method level", Boolean.TRUE) ; 
		mapPropositions.put("Interceptors can be specified at the class level", Boolean.TRUE) ;
		mapPropositions.put("Interceptors can be specified at the ejb-jar level", Boolean.TRUE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("Which transaction attributes make sense used with a Message-Driven Bean?") ;
		question = new Question("EJB", string.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("REQUIRED", Boolean.TRUE) ; 
		mapPropositions.put("REQUIRED_NEW", Boolean.FALSE) ;
		mapPropositions.put("SUPPORTS", Boolean.FALSE) ; 
		mapPropositions.put("MANDATORY", Boolean.FALSE) ;
		mapPropositions.put("NOT_SUPPORTED", Boolean.TRUE) ;
		mapPropositions.put("NEVER", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("In a JSP, which implicit object can access the attributes from the ServletContext?") ;
		question = new Question("JSP/Servlet", string.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("server", Boolean.FALSE) ; 
		mapPropositions.put("context", Boolean.FALSE) ;
		mapPropositions.put("request", Boolean.FALSE) ; 
		mapPropositions.put("application", Boolean.TRUE) ;
		mapPropositions.put("servletContext", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("if req is a reference to an HttpServletRequest and there is no current session, what is true about req.getSession() ?") ;
		question = new Question("JSP/Servlet", string.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Invoking req.getSession() will return null.", Boolean.FALSE) ; 
		mapPropositions.put("Invoking req.getSession(true) will return null.", Boolean.FALSE) ;
		mapPropositions.put("Invoking req.getSession(false) will return null", Boolean.TRUE) ; 
		mapPropositions.put("Invoking req.getSession() will return a new session.", Boolean.TRUE) ;
		mapPropositions.put("Invoking req.getSession(true) will return a new session.", Boolean.TRUE) ;
		mapPropositions.put("Invoking req.getSession(false) will return a new session.", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("What is generally true about the lifecycle of a servlet ? ") ;
		question = new Question("JSP/Servlet", string.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("You should NOT write a constructor for a servlet.", Boolean.TRUE) ; 
		mapPropositions.put("You should NOT override a servlet's init() method.", Boolean.FALSE) ;
		mapPropositions.put("You should NOT override a servlet's doGet() method.", Boolean.FALSE) ; 
		mapPropositions.put("You should NOT override a servlet's doPost() method.", Boolean.FALSE) ;
		mapPropositions.put("You should NOT override a servlet's service() method.", Boolean.TRUE) ;
		mapPropositions.put("You should NOT override a servlet's destroy() method.", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("JSP/Servlet", "Is a servlet thread-safe ?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Yes", Boolean.FALSE) ; 
		mapPropositions.put("No", Boolean.TRUE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("Which patterns are likely to be used to hide the complex JNDI lookup ? (choose two answers)") ;
		question = new Question("JSP/Servlet", string.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Adapter", Boolean.FALSE) ; 
		mapPropositions.put("Service locator", Boolean.TRUE) ;
		mapPropositions.put("Visitor", Boolean.FALSE) ; 
		mapPropositions.put("Decorator", Boolean.FALSE) ;
		mapPropositions.put("Business delegate", Boolean.TRUE) ;
		mapPropositions.put("Interpreter", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		string = new StringBuilder() ; 
		string.append("Consider the case given in the example: Event and Person are two entities and there is a many to many mapping between them." + "[NL]") ;
		string.append("[code style=java]") ;
		string.append("Event e=(Event)session.load(Event.class,eid);") ;
		string.append("[NL]").append("Person p=(Person)session.load(Person.class,pid);") ;
		string.append("[NL]").append("p.getEvents().add(e);") ; 
		string.append("[NL]").append("e.getPersons().add(p);") ;
		string.append("[NL]").append("return p;") ; 
		string.append("[/code]") ;
		question = new Question("Hibernate", 
				string.toString() + "Which keyword must we use in the mapping file to avoid to insert twice in the join table PERSON_EVENTS? (suppose that we use a hibernate mapping file for the mapping)", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Discard=[DB]true[DB]", Boolean.FALSE) ; 
		mapPropositions.put("singleInsert=[DB]true[DB]", Boolean.FALSE) ;
		mapPropositions.put("inverse=[DB]true[DB]", Boolean.TRUE) ; 
		mapPropositions.put("reverse=[DB]true[DB]", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		return mapQuestions ; 
	}

	private TestSheet createTestCsharp () {
        TestSheet testCsharp = new TestSheet() ;
        testCsharp.setDuree(30);
        testCsharp.setIntitule("Test C#");
        testCsharp.setType("C#");
        
        Map <Question , Map <String , Boolean>> mapQuestions = questionsCsharp() ; 
        fillAllQuestions(testCsharp, mapQuestions) ; 
        
        return testCsharp ; 
    }
	
	private Map<Question, Map<String, Boolean>> questionsCsharp () {
		
		Map <Question , Map <String , Boolean>> mapQuestions = new LinkedHashMap <Question , Map <String , Boolean>>() ; 
		Map <String , Boolean> mapPropositions = new LinkedHashMap <String , Boolean> () ; 
		
		StringBuilder content = new StringBuilder() ; 
		content.append("Given the following :" + "[NL]") ; 
		content.append("[code style=csharp]") ;
		content.append("class A {") ;
		content.append("[NL]").append("}[NL]") ;
		content.append("[NL]").append("class B:A {") ;
		content.append("[NL][TAB]").append("public void Print() {") ;
		content.append("[NL][TAB][TAB]").append("Console.WriteLine([DB]B[DB]);") ;
		content.append("[NL][TAB]").append("}").append("[NL]").append("}[NL]") ;
		content.append("[NL]").append("class C:A {") ;
		content.append("[NL]").append("}[NL]") ;
		content.append("[NL]").append("class Program {") ;
		content.append("[NL][TAB]").append("static void Main(string[] args) {") ;
		content.append("[NL][TAB][TAB]").append("A[] tab = { new C(), new A(), new B() };") ;
		content.append("[NL][TAB][TAB]").append("foreach(A a in tab) {") ;
		content.append("[NL][TAB][TAB][TAB]").append("a.Print();//Compilation error") ;
		content.append("[NL][TAB][TAB]").append("}") ;
		content.append("[NL][TAB]").append("}").append("[NL]").append("}") ;
		content.append("[/code]") ;
		Question question = new Question("Static and Dynamic Cast", "What should be modified in the following program to make it compile and run normally?[NL][NL]" + content.toString() , Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		
		content = new StringBuilder() ; 
		content.append("[code style=csharp]") ;
		content.append("if (a is B){") ;
		content.append("[NL][TAB]").append("a.Print();") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		mapPropositions.put(content.toString(), Boolean.FALSE) ; 
		
		content = new StringBuilder() ; 
		content.append("[code style=csharp]") ;
		content.append("if (a is B){") ;
		content.append("[NL][TAB]").append("B b = (B)a;") ;
		content.append("[NL][TAB]").append("b.Print();") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		mapPropositions.put(content.toString(), Boolean.TRUE) ; 
		
		content = new StringBuilder() ; 
		content.append("[code style=csharp]") ;
		content.append("B b = a as B;") ;
		content.append("[NL]").append("b.Print();") ;
		content.append("[/code]") ;
		mapPropositions.put(content.toString(), Boolean.FALSE) ; 
		
		content = new StringBuilder() ; 
		content.append("[code style=csharp]") ;
		content.append("B b = a as B;") ;
		content.append("[NL]").append("if (b != null)") ;
		content.append("[NL][TAB]").append("b.Print();") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		mapPropositions.put(content.toString(), Boolean.TRUE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Interfaces - Multiple Inheritance", "What is the alternative to multiple inheritance in C# ?", Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("interface", Boolean.TRUE) ; 
		mapPropositions.put("abstract class", Boolean.FALSE) ; 
		mapPropositions.put("static class", Boolean.FALSE) ; 
		mapPropositions.put("delegate", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;

		question = new Question("C# Compilation Unit", "A C# program is compiled ...", Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("into a CLR file", Boolean.FALSE) ; 
		mapPropositions.put("into an IL file", Boolean.TRUE) ; 
		mapPropositions.put("into a binary file", Boolean.FALSE) ; 
		mapPropositions.put("into a COM file", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		content = new StringBuilder() ; 
		content.append("[code style=csharp]") ;
		content.append("class Person{") ; 
		content.append("[NL][TAB]").append("private string Name;[NL]") ;
		content.append("[NL][TAB]").append("public Person(string name) {[NL][TAB][TAB]Name = name;[NL][TAB]}[NL]") ;
		content.append("[NL][TAB]").append("public override string ToString() {[NL][TAB][TAB]return Name;[NL][TAB]}[NL]") ;
		content.append("[NL][TAB]").append("public Person Copy1() {[NL][TAB][TAB]return new Person(Name);[NL][TAB]}[NL]") ;
		content.append("[NL][TAB]").append("public Person Copy2() {[NL][TAB][TAB]return this;[NL][TAB]}[NL]") ;
		content.append("[NL][TAB]").append("public void Append(string s) {[NL][TAB][TAB]Name += s;[NL][TAB]}") ;
		content.append("[NL]").append("}") ;
		content.append("[NL][NL]").append("class Program{") ;
		content.append("[NL][TAB]").append("static void Main(string[] args){") ;
		content.append("[NL][TAB][TAB]").append("Person p = new Person([DB]a[DB]);") ;
		content.append("[NL][TAB][TAB]").append("Person p2 = p;") ;
		content.append("[NL][TAB][TAB]").append("p2.Append([DB]b[DB]);") ;
		content.append("[NL][TAB][TAB]").append("Person p3 = p.Copy1();") ;
		content.append("[NL][TAB][TAB]").append("p3.Append([DB]c[DB]);") ;
		content.append("[NL][TAB][TAB]").append("Person p4 = p.Copy2();") ;
		content.append("[NL][TAB][TAB]").append("p4.Append([DB]d[DB]);") ;
		content.append("[NL][TAB][TAB]").append("Console.WriteLine([DB]{0},{1},{2},{3}[DB], p, p2, p3, p4);") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		question = new Question("Deep Copy & Shalow Copy", "What is the output of the following program:[NL][NL]" + content.toString(), Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("a,ab,ac,ad", Boolean.FALSE) ; 
		mapPropositions.put("abcd,abcd,abcd,abcd", Boolean.FALSE) ; 
		mapPropositions.put("abcd,b,c,d", Boolean.FALSE) ; 
		mapPropositions.put("abd,abd,abc,abc", Boolean.FALSE) ;
		mapPropositions.put("abd,abd,abc,abd", Boolean.TRUE) ;
		mapQuestions.put(question, mapPropositions) ;

		content = new StringBuilder() ; 
		content.append("[code style=csharp]") ;
		content.append("public class A {") ; 
		content.append("[NL][TAB]").append("private string Id = [DB]base[DB];[NL]") ;
		content.append("[NL][TAB]").append("public A() { }[NL]") ;
		content.append("[NL][TAB]").append("public A(string id) {[NL][TAB][TAB]Id = id;[NL][TAB]}[NL]") ;
		content.append("[NL][TAB]").append("public virtual void Display() {") ;
		content.append("[NL][TAB][TAB]").append("Console.Write(Id);") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL]").append("}") ;
		content.append("[NL][NL]").append("public class B:A {") ;
		content.append("[NL][TAB]").append("private string Id_b;[NL]") ;
		content.append("[NL][TAB]").append("public B(string id): base(id) {[NL][TAB][TAB]Id_b = id;[NL][TAB]}[NL]") ;
		content.append("[NL][TAB]").append("public override void Display() {") ;
		content.append("[NL][TAB][TAB]").append("base.Display();") ;
		content.append("[NL][TAB][TAB]").append("Console.Write(Id_b);") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL]").append("}") ;
		content.append("[NL][NL]").append("public class C:A {") ;
		content.append("[NL][TAB]").append("public void Display() {") ;
		content.append("[NL][TAB][TAB]").append("Console.Write([DB]C[DB]);") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL]").append("}") ;
		content.append("[NL][NL]").append("class Program {") ;
		content.append("[NL][TAB]").append("static void Main(string[] args) {") ;
		content.append("[NL][TAB][TAB]").append("List<A> list = new List<A>();") ;
		content.append("[NL][TAB][TAB]").append("list.Add(new C());  list.Add(new A([DB]A[DB]));  list.Add(new B([DB]B[DB]));") ;
		content.append("[NL][TAB][TAB]").append("foreach(A a in list) { a.Display();}") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		question = new Question("Inheritance and virtual methods", "What is the output of the following program:[NL][NL]" + content.toString(), Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("CbasebaseB", Boolean.FALSE) ; 
		mapPropositions.put("CAbaseB", Boolean.FALSE) ; 
		mapPropositions.put("baseAbaseB", Boolean.FALSE) ; 
		mapPropositions.put("baseABBA", Boolean.TRUE) ;
		mapQuestions.put(question, mapPropositions) ;

		question = new Question("The Readonly keyword", "A readonly field ...", Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("is initialized once", Boolean.TRUE) ; 
		mapPropositions.put("can be assigned at declaration", Boolean.TRUE) ; 
		mapPropositions.put("can be assigned in the class constructor", Boolean.TRUE) ; 
		mapPropositions.put("can only be assigned in the class constructor", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		question = new Question(".Net Class Framework", "What is the ultimate class of all .Net classes?" , Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("System", Boolean.FALSE) ; 
		mapPropositions.put("Sytem.Addin", Boolean.FALSE) ; 
		mapPropositions.put("System.Class", Boolean.FALSE) ; 
		mapPropositions.put("System.Object", Boolean.TRUE) ;
		mapPropositions.put("System.Data", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		question = new Question("String and StringBuilder classes", "Tick the correct answer(s)", Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("A String object is mutable", Boolean.FALSE) ; 
		mapPropositions.put("A string object can be changed either by referencing another string object or by creating a new string", Boolean.TRUE) ; 
		mapPropositions.put("A StringBuilder object is immutable", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		content = new StringBuilder() ; 
		content.append("[code style=csharp]") ;
		content.append("class Identifiant {").append("") ;
		content.append("[NL][TAB]").append("private string Id;[NL]") ;
		content.append("[NL][TAB]").append("public Identifiant(string id) {") ;
		content.append("[NL][TAB][TAB]").append("Id = id;") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL][TAB]").append("public void Calcul();") ;
		content.append("[NL]").append("}[NL]") ;
		content.append("[NL]").append("class Personne:Identifiant {") ;
		content.append("[NL][TAB]").append("private string Name;[NL]") ;
		content.append("[NL][TAB]").append("public Personne(string name): base() {") ;
		content.append("[NL][TAB][TAB]").append("Name = name;") ;
		content.append("[NL][TAB]").append("}[NL]") ;
		content.append("[NL][TAB]").append("public void Operation() {") ;
		content.append("[NL][TAB][TAB]").append("Console.WriteLine([DB]operation[DB]);") ;
		content.append("[NL][TAB]").append("}[NL]") ;
		content.append("[NL][TAB]").append("public override void Calcul() {") ;
		content.append("[NL][TAB][TAB]").append("Console.WriteLine([DB]calcul[DB]);") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		question = new Question("Inheritance", "What modifications are needed to make this program compile?[NL][NL]" + content.toString(), Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("to provide a parameterless constructor", Boolean.TRUE) ; 
		mapPropositions.put("to declare abstract the Calcul method", Boolean.TRUE) ; 
		mapPropositions.put("to declare abstract the Identifiant class", Boolean.TRUE) ; 
		mapPropositions.put("to declare virtual the Calcul method", Boolean.FALSE) ;
		mapPropositions.put("to declare protected the Id field of the Identifiant class", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		content = new StringBuilder() ; 
		content.append("[code style=csharp]") ;
		content.append("class Program {").append("") ;
		content.append("[NL][TAB]").append("static void main (String[] args) {") ;
		content.append("[NL][TAB][TAB]").append("try {") ;
		content.append("[NL][TAB][TAB][TAB]").append("int i = 8, j = 4;") ;
		content.append("[NL][TAB][TAB][TAB]").append("for(int k = 0; k < 5; k ++) {") ;
		content.append("[NL][TAB][TAB][TAB]").append("Console.write([DB]{0}[DB], i / j);") ;
		content.append("[NL][TAB][TAB][TAB]").append("i = i - 2;") ;
		content.append("[NL][TAB][TAB][TAB]").append("j --;") ;
		content.append("[NL][TAB][TAB]").append("}") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL][TAB]").append("catch {") ;
		content.append("[NL][TAB][TAB]").append("Console.writeLine([DB]\\nerror detected[DB]);") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL][TAB]").append("finally {") ;
		content.append("[NL][TAB][TAB]").append("Console.writeLine([DB]end[DB]);") ;
		content.append("[NL][TAB]").append("}[NL]") ;
		content.append("[NL]").append("}[NL]") ;
		content.append("[/code]") ;
		question = new Question("Exception catching", "What is the output of the following program?[NL][NL]" + content.toString(), Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("error detected"+ "[NL]" + "end", Boolean.FALSE) ; 
		mapPropositions.put("2222"+ "[NL]" + "error detected", Boolean.FALSE) ; 
		mapPropositions.put("2222"+ "[NL]" + "end", Boolean.FALSE) ; 
		mapPropositions.put("22222" , Boolean.FALSE) ;
		mapPropositions.put("2222"+ "[NL]" + "error detected"+ "[NL]" + "end", Boolean.TRUE) ;
		mapPropositions.put("end", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		question = new Question("Value Types - Reference Types", "Tick the correct answer(s):", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Array types are value types", Boolean.FALSE) ; 
		mapPropositions.put("Reference types are stored on the stack", Boolean.FALSE) ; 
		mapPropositions.put("An operation on one reference type variable may affect another reference variable", Boolean.TRUE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Assembly and Manifest", "Tick the correct answer(s)", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("An assembly consists of a unique file", Boolean.FALSE) ; 
		mapPropositions.put("The manifest describes the identity of the assembly", Boolean.TRUE) ;
		mapPropositions.put("The manifest gives information on referenced assemblies", Boolean.TRUE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Singleton design pattern", "Which design pattern insures that only one instance of a class can be instanciated?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Adaptor", Boolean.FALSE) ; 
		mapPropositions.put("Facade", Boolean.FALSE) ; 
		mapPropositions.put("Decorator", Boolean.FALSE) ; 
		mapPropositions.put("Singleton", Boolean.TRUE) ;
		mapPropositions.put("Bridge", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Generics: HashTable and Dictionary", "What is the difference between the Hashtable and Dictionary collections?",
				Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Dictionary is organized based on the hash code of the key", Boolean.FALSE) ; 
		mapPropositions.put("Dictionary is a generic collection", Boolean.TRUE) ; 
		mapPropositions.put("HasTable is generic collection", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		content = new StringBuilder() ; 
		content.append("[code style=csharp]") ;
		content.append("public class A {") ;
		content.append("[NL][TAB]").append("private static A a;[NL]") ;
		content.append("[NL][TAB]").append("private A() { }[NL]") ;
		content.append("[NL][TAB]").append("public static A Operation() {") ;
		content.append("[NL][TAB][TAB]").append("if(a == null) {") ;
		content.append("[NL][TAB][TAB][TAB]").append("a = new A();") ;
		content.append("[NL][TAB][TAB]").append("}") ;
		content.append("[NL][TAB][TAB]").append("return a;") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		question = new Question("Singleton design Pattern", "Which design pattern is implemented below?[NL][NL]" + content.toString(), Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Adaptor", Boolean.FALSE) ; 
		mapPropositions.put("Facade", Boolean.FALSE) ; 
		mapPropositions.put("Decorator", Boolean.FALSE) ; 
		mapPropositions.put("Singleton", Boolean.TRUE) ;
		mapPropositions.put("Bridge", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Boxing conversion", "The following instruction:[NL][NL][code style=csharp]" + "3.ToString();" + "[/code]", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("does not compile", Boolean.FALSE) ; 
		mapPropositions.put("is a boxing conversion", Boolean.TRUE) ; 
		mapPropositions.put("is an unboxing conversion", Boolean.FALSE) ; 
		mapPropositions.put("is a litteral conversion", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("IEnumerable interface", "The foreach loop ..." , Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("can be applied to objects of any class", Boolean.FALSE) ;
		mapPropositions.put("can only be applied to collections", Boolean.FALSE) ;
		mapPropositions.put("can only be applied to classes implementing the IEnumerable interface", Boolean.TRUE) ;
		mapPropositions.put("can only be applied to classes implementing the IEnumerator interface", Boolean.FALSE) ;
		mapPropositions.put("can only be applied to classes implementing the IEnumerate interface", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("delegates", "Tick the correct answer(s)", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("A delegate is a type that defines a method signature", Boolean.TRUE) ; 
		mapPropositions.put("A delegate is a method overloaded in a derived class", Boolean.FALSE) ; 
		mapPropositions.put("A delegate object encapsulates a reference to a method", Boolean.TRUE) ; 
		mapPropositions.put("A delegate allow methods to be passed as parameters", Boolean.TRUE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("IEnumeator interface", "A class Implementing the IEnumerator interface must implement ...", Niveau.SENIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("[code style=csharp]void Reset()[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=csharp]void Size{get;}[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=csharp]IEnumerator GetEnumerator()[/code]", Boolean.FALSE) ;
		mapPropositions.put("[code style=csharp]bool MovePrevious()[/code]", Boolean.FALSE) ;
		mapPropositions.put("[code style=csharp]bool MoveNext()[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=csharp]Object Current{get;}[/code]", Boolean.TRUE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		content = new StringBuilder() ; 
		content.append("[code style=csharp]") ;
		content.append("public interface Iinterf1 {").append("") ;
		content.append("[NL][TAB]").append("void Operation1();") ;
		content.append("[NL]").append("}") ;
		content.append("[NL]").append("public class Component1:Iinterf1 {") ;
		content.append("[NL][TAB]").append("public void Operation1() {") ;
		content.append("[NL][TAB][TAB]").append("Console.WriteLine([DB]operation1[DB]);") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL]").append("}") ;
		content.append("[NL]").append("public interface Iinterf2 {") ;
		content.append("[NL][TAB]").append("void Operation2();") ;
		content.append("[NL]").append("}") ;
		content.append("[NL]").append("public class Component2:Iinterf2 {") ;
		content.append("[NL][TAB]").append("Component1 Component1;") ;
		content.append("[NL][TAB]").append("public Component2(Component1 component1) {") ;
		content.append("[NL][TAB][TAB]").append("Component1 = component1;") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL][TAB]").append("public void Operation2() {") ;
		content.append("[NL][TAB][TAB]").append("Console.WriteLine([DB]operation2[DB]);") ;
		content.append("[NL][TAB][TAB]").append("Component1.Operation1();") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL]").append("}") ;
		content.append("[NL]").append("class Program }") ;
		content.append("[NL][TAB]").append("static void Main(string[] args) {") ;
		content.append("[NL][TAB][TAB]").append("Component2 comp = new Component2(new Component1());") ;
		content.append("[NL][TAB][TAB]").append("comp.Operation2();") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ; 
		question = new Question("Adaptor Pattern", "Which design pattern is implemented below?[NL]" + content.toString(), Niveau.SENIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Adaptor", Boolean.TRUE) ; 
		mapPropositions.put("Facade", Boolean.FALSE) ; 
		mapPropositions.put("Decorator", Boolean.FALSE) ; 
		mapPropositions.put("Singleton", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		return mapQuestions ; 
	}

	private TestSheet createTestCplusplus () {
        TestSheet testCplusplus = new TestSheet() ;
        testCplusplus.setDuree(30);
        testCplusplus.setIntitule("Test C++");
        testCplusplus.setType("C++");
        
        Map <Question , Map <String , Boolean>> mapQuestions = questionsCplusplus() ; 
        fillAllQuestions(testCplusplus, mapQuestions) ; 
        
        return testCplusplus ; 
    }
	
	private Map<Question, Map<String, Boolean>> questionsCplusplus () {
		
		Map <Question , Map <String , Boolean>> mapQuestions = new LinkedHashMap <Question , Map <String , Boolean>>() ; 
		Map <String , Boolean> mapPropositions = new LinkedHashMap <String , Boolean> () ; 
		
		StringBuilder content = new StringBuilder() ; 
		content.append("[code style=cpp]") ;
		content.append("for(int i=1; i<=3 ; i++) {") ;
		content.append("[NL][TAB]").append("if (i=1) ") ;
		content.append("[NL][TAB][TAB]").append("std::cout << [DB] i=1[DB]; ") ;
		content.append("[NL][TAB]").append("else ") ;
		content.append("[NL][TAB][TAB]").append("std::cout << [DB] i=[DB] << i; ") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ; 
		Question question = new Question("for if", "What will be the ouput of the following code?[NL][NL]" + content.toString() , Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("i=1 i=2", Boolean.FALSE) ; 
		mapPropositions.put("i=1 i=2 i=3", Boolean.FALSE) ; 
		mapPropositions.put("i=1 i=2 i=3 i=4 i=5 i=6 i=7......", Boolean.FALSE) ; 
		mapPropositions.put("i=1 i=1", Boolean.FALSE) ; 
		mapPropositions.put("i=1 i=1 i=1", Boolean.FALSE) ; 
		mapPropositions.put("i=1 i=1 i=1 i=1 i=1 i=1 i=1....", Boolean.TRUE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		content = new StringBuilder() ; 
		content.append(	"Consider the following code :") ; 
		content.append("[code style=cpp]"+ "[NL]") ;
		content.append("double r = 6.28; " + "[NL]") ;
		content.append("const double  PI = 3.14; " + "[NL]") ;
		content.append("const double * pPI; ") ;
		content.append("[/code]") ; 
		content.append("[NL][NL]") ;
		content.append("Which statement(s) is(are) illegal among the following ones?") ; 
		content.append("[NL][NL]") ;
		content.append("[code style=cpp]") ;
		content.append("pPI = &PI;") ;
		content.append("[NL]").append("pPI = &r;") ;
		content.append("[NL]").append("*pPI = PI;") ;
		content.append("[NL]").append("r = *pPI;") ;
		content.append("[/code]") ; 
		question = new Question("const-pointer-reference", content.toString(), Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("pPI = &PI;", Boolean.FALSE) ; 
		mapPropositions.put("pPI = &r;", Boolean.FALSE) ; 
		mapPropositions.put("*pPI = PI;", Boolean.TRUE) ; 
		mapPropositions.put("r = *pPI;", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;

		question = new Question("Reference", "What's the reference of an object?", Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("A copy of an object ", Boolean.FALSE) ; 
		mapPropositions.put("A pointer to a const object", Boolean.FALSE) ; 
		mapPropositions.put("A pointer to a non const object", Boolean.FALSE) ; 
		mapPropositions.put("An alias for an object ", Boolean.TRUE) ;
		mapQuestions.put(question, mapPropositions) ;

		question = new Question("delete", "What does the statement[NL][code style=cpp]delete p;[/code]?" , Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("It depends of the type of p.", Boolean.FALSE) ; 
		mapPropositions.put("It destroys data pointed by p and sets the pointer to NULL", Boolean.FALSE) ; 
		mapPropositions.put("It destroys data pointed by p.", Boolean.TRUE) ; 
		mapPropositions.put("It destroys the pointer p.", Boolean.FALSE) ;
		mapPropositions.put("It sets the pointer to NULL.", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		content = new StringBuilder() ; 
		content.append("Consider the following statement :") ; 
		content.append("[NL]").append("[code style=cpp]" + "X *pX = new X[100];" + "[/code]") ;
		question = new Question("Clean memory", content.toString() + "How to destroy pX?" , Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("delete pX;", Boolean.FALSE) ; 
		mapPropositions.put("delete [ ] pX;", Boolean.TRUE) ; 
		mapPropositions.put("delete pX [ ];", Boolean.FALSE) ; 
		mapPropositions.put("delete [100] pX;", Boolean.FALSE) ;
		mapPropositions.put("delete pX[100];", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		question = new Question("Friend", "What is the meaning of friend?", Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("A keywork for multiple inheritance", Boolean.FALSE) ; 
		mapPropositions.put("A keywork to allow a class or a function to have access to the private and protected membres of a class", Boolean.TRUE) ; 
		mapPropositions.put("A keyword to share memory", Boolean.FALSE) ; 
		mapPropositions.put("A keyword to propagate exceptions", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		content = new StringBuilder() ; 
		content.append("[code style=cpp]").append("[NL]") ; 
		content.append("#include <iostream>").append("") ;
		content.append("[NL]").append("class X {") ;
		content.append("[NL][TAB]").append("public:") ;
		content.append("[NL][TAB]").append("X() { std::cout << 0; }") ;
		content.append("[NL][TAB]").append("~X() { std::cout << 1; }") ;
		content.append("[NL]").append("};") ;
		content.append("[NL][NL]").append("class Y : public X {") ;
		content.append("[NL][TAB]").append("public:") ;
		content.append("[NL][TAB]").append("Y() { std::cout << 2; }") ;
		content.append("[NL][TAB]").append("~Y() { std::cout << 3; }") ;
		content.append("[NL]").append("};") ;
		content.append("[NL][NL]").append("int main() {") ;
		content.append("[NL][TAB]").append("Y y;") ;
		content.append("[NL][TAB]").append("return 0;") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		question = new Question("Construction/destruction order", "What is the output of the following code?[NL][NL]" + content.toString(), Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("23", Boolean.FALSE) ; 
		mapPropositions.put("32", Boolean.FALSE) ; 
		mapPropositions.put("0231", Boolean.TRUE) ;
		mapPropositions.put("0213", Boolean.FALSE) ; 
		mapPropositions.put("2013", Boolean.FALSE) ;
		mapPropositions.put("2031", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;

		question = new Question("Dynamic polymorphism", "What is necesseray for dynamic polymorphism?", Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("overriden methods", Boolean.FALSE) ; 
		mapPropositions.put("abstract methods", Boolean.FALSE) ; 
		mapPropositions.put("overloaded methods", Boolean.FALSE) ;
		mapPropositions.put("virtual methods", Boolean.TRUE) ; 
		mapPropositions.put("static methods", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		content = new StringBuilder() ; 
		content.append("[code style=cpp]").append("[NL]") ; 
		content.append("#include <iostream>").append("") ;
		content.append("[NL]").append("class A{ ") ;
		content.append("[NL][TAB]").append("public:") ;
		content.append("[NL][TAB]").append("void f(){ std::cout<<[DB]A ;}") ;
		content.append("[NL]").append("};") ;
		content.append("[NL][NL]").append("struct B : public A	{ ") ;
		content.append("[NL][TAB]").append("public:") ;
		content.append("[NL][TAB]").append("void f(){ std::cout<<[DB]B [DB];}") ;
		content.append("[NL]").append("};") ;
		content.append("[NL][NL]").append("int main() {") ;
		content.append("[NL][TAB]").append("A a;") ;
		content.append("[NL][TAB]").append("B b;") ;
		content.append("[NL][TAB]").append("A *c( &b );") ;
		content.append("[NL][TAB]").append("A &d( *c );") ;
		content.append("[NL][TAB]").append("a.f();") ;
		content.append("[NL][TAB]").append("b.f();") ;
		content.append("[NL][TAB]").append("c->f();") ;
		content.append("[NL][TAB]").append("d.f();") ;
		content.append("[NL][TAB]").append("return 0;") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		question = new Question("Polymorphism", "What is the output of the following code?[NL][NL]" + content.toString(), Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("A A A A", Boolean.FALSE) ; 
		mapPropositions.put("A B A A", Boolean.TRUE) ; 
		mapPropositions.put("A B B B", Boolean.FALSE) ; 
		mapPropositions.put("A B B A", Boolean.FALSE) ;
		mapPropositions.put("A B A B", Boolean.FALSE) ;
		mapPropositions.put("A A B A", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		content = new StringBuilder() ; 
		content.append("[code style=cpp]").append("[NL]") ; 
		content.append("#include <iostream>").append("") ;
		content.append("[NL]").append("class A{ ") ;
		content.append("[NL][TAB]").append("public:") ;
		content.append("[NL][TAB]").append("virtual void f() { std::cout<<[DB]A [DB];}") ;
		content.append("[NL]").append("};") ;
		content.append("[NL][NL]").append("struct B : public A	{ ") ;
		content.append("[NL][TAB]").append("public:") ;
		content.append("[NL][TAB]").append("virtual void f() { std::cout<<[DB]B [DB];}") ;
		content.append("[NL]").append("};") ;
		content.append("[NL][NL]").append("int main() {") ;
		content.append("[NL][TAB]").append("A a;") ;
		content.append("[NL][TAB]").append("B b;") ;
		content.append("[NL][TAB]").append("A *c( &b );") ;
		content.append("[NL][TAB]").append("A &d( *c );") ;
		content.append("[NL][TAB]").append("a.f();") ;
		content.append("[NL][TAB]").append("b.f();") ;
		content.append("[NL][TAB]").append("c->f();") ;
		content.append("[NL][TAB]").append("d.f();") ;
		content.append("[NL][TAB]").append("return 0;") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		question = new Question("Polymorphism", "What is the output of the following program?[NL][NL]" + content.toString(), Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("A A A A", Boolean.FALSE) ; 
		mapPropositions.put("A B A A", Boolean.FALSE) ; 
		mapPropositions.put("A B B B", Boolean.TRUE) ; 
		mapPropositions.put("A B B A", Boolean.FALSE) ;
		mapPropositions.put("A B A B", Boolean.FALSE) ;
		mapPropositions.put("A A B A", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;

		question = new Question("Abstract class", "What's an abstract class?", Niveau.JUNIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("A class whose all members are privated and/or protected", Boolean.FALSE) ; 
		mapPropositions.put("A class with at least one pure virtual method", Boolean.TRUE) ; 
		mapPropositions.put("A class without members", Boolean.FALSE) ; 
		mapPropositions.put("A class whose all methods are virtual.", Boolean.FALSE) ; 
		mapPropositions.put("A class without inheritance", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Default constructor", "What happen if no constructor is defined in a class?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("The compilator generates a constructor which initializes all members to NULL or 0. ", Boolean.FALSE) ; 
		mapPropositions.put("The compilator generates a constructor which does nothing.", Boolean.TRUE) ;
		mapPropositions.put("The class doesn't compile.", Boolean.FALSE) ;
		mapPropositions.put("Nothing.", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Affectation operator", "What happen if no affectation operator is defined in a class?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("It doesn't compile.", Boolean.FALSE) ; 
		mapPropositions.put("The compilator generates an = operator which does nothing.", Boolean.FALSE) ; 
		mapPropositions.put("The compilator calls the copy constructor.", Boolean.FALSE) ; 
		mapPropositions.put("The compilator generates a = operator which copies all members one by one.", Boolean.TRUE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		content = new StringBuilder() ; 
		content.append("Consider the code below").append("[NL]") ; 
		content.append("[code style=cpp]").append("[NL]") ; 
		content.append("C                objC;") ;
		content.append("[NL]").append("C& robjC  = objC;") ;
		content.append("[/code]") ;
		question = new Question("Affectation operator", content.toString() + "Which statement(s) call the affectation operator of the class C?", Niveau.INTERMEDIAIRE) ;
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("C tmpC = objC;", Boolean.FALSE) ; 
		mapPropositions.put("tmpC.operator=( objC );", Boolean.TRUE) ; 
		mapPropositions.put("objC = tmpC;", Boolean.TRUE) ; 
		mapPropositions.put("robjC = tmpC;", Boolean.TRUE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Copy constructor", "For the class A, what is the signature of its copy constructor?", Niveau.INTERMEDIAIRE) ;
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("[code style=cpp]const A& A::A(const A&);[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=cpp]A& A::A(const A& );[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=cpp]A A::A(A rArg);[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=cpp]A::A(const A rArg);[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=cpp]A::A(A rArg);[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=cpp]A::A(const A& rArg);[/code]", Boolean.TRUE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		content = new StringBuilder() ; 
		content.append("[code style=cpp]").append("[NL]") ; 
		content.append("#include <iostream>").append("") ;
		content.append("[NL]").append("class Exception_A {};") ;
		content.append("[NL]").append("class Exception_B : virtual public Exception_A {};") ;
		content.append("[NL]").append("class Exception_C : public Exception_B {};") ;
		content.append("[NL][NL]").append("int main() {") ;
		content.append("[NL][TAB]").append("try {") ;
		content.append("[NL][TAB][TAB]").append("throw Exception_B();") ;
		content.append("[NL][TAB]").append("}") ;
		content.append("[NL][TAB]").append("catch(Exception_C){ std::cout<<[DB]Add[DB]<<std::endl; }") ;
		content.append("[NL][TAB]").append("catch(Exception_A){ std::cout<<[DB]Stones[DB]<<std::endl; }") ;
		content.append("[NL][TAB]").append("catch(Exception_B){ std::cout<<[DB]AddStones[DB]<<std::endl; ") ;
		content.append("[NL][TAB]").append("return 0;") ;
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		question = new Question("Exception", "What is the output of the following code?[NL][NL]" + content.toString() , Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Add", Boolean.FALSE) ; 
		mapPropositions.put("Stones", Boolean.TRUE) ; 
		mapPropositions.put("AddStones", Boolean.FALSE) ; 
		mapPropositions.put("Nothing", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Static polymorphism", "Which word makes you think about static polymorphism?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("virtual", Boolean.FALSE) ;
		mapPropositions.put("template", Boolean.TRUE) ;
		mapPropositions.put("static", Boolean.FALSE) ;
		mapPropositions.put("abstract", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Stream", "Which function allows a class C to be used by cout? ", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("[code style=cpp]ostream& C::operator << (ostream &);[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=cpp]ostream& operator << (ostream &, const C&);[/code]", Boolean.TRUE) ; 
		mapPropositions.put("[code style=cpp]void C::operator << (ostream & );[/code]", Boolean.FALSE) ; 
		mapPropositions.put("[code style=cpp]void operator << (const C&, ostream &);[/code]", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("STL containers", "Which of the fllowing are containers from the STL?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("vector", Boolean.TRUE) ; 
		mapPropositions.put("list", Boolean.TRUE) ; 
		mapPropositions.put("deque", Boolean.TRUE) ; 
		mapPropositions.put("multimap", Boolean.TRUE) ;
		mapPropositions.put("set", Boolean.TRUE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("Singleton design pattern", "Which design pattern insures that only one instance of a class can be instanciated?", Niveau.INTERMEDIAIRE) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Adapter", Boolean.FALSE) ; 
		mapPropositions.put("Facade", Boolean.FALSE) ; 
		mapPropositions.put("Decorator", Boolean.FALSE) ; 
		mapPropositions.put("Singleton", Boolean.TRUE) ;
		mapPropositions.put("Prototype", Boolean.FALSE) ; 
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("RAII", "RAII is a programming idiom...", Niveau.SENIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("to improve research algorithms by increment.", Boolean.FALSE) ; 
		mapPropositions.put("to allocate a resource in the constructor of a class, and deallocate it in its destructor in a easy and safe way", Boolean.TRUE) ; 
		mapPropositions.put("to read all information in only one instruction. ", Boolean.FALSE) ;
		mapPropositions.put("to refence abstract and invariant interface ", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		content = new StringBuilder() ; 
		content.append("[code style=cpp]").append("[NL]") ; 
		content.append("#include <iostream>").append("") ;
		content.append("[NL]").append("class IComponent{") ;
		content.append("[NL][TAB]").append("public : ") ;
		content.append("[NL][TAB][TAB]").append("virtual void Action() = 0;") ;
		content.append("[NL][TAB]").append("};") ;
		content.append("[NL]").append("class Component{") ;
		content.append("[NL][TAB]").append("public : ") ;
		content.append("[NL][TAB][TAB]").append("Component ( )  {};") ;
		content.append("[NL][TAB][TAB]").append("void ActionComponent(){ std::cout<<[DB]Component does something[DB];}") ;
		content.append("[NL][TAB]").append("};") ;
		content.append("[NL]").append("class Component2 : public IComponent , private Component {") ;
		content.append("[NL][TAB]").append("public : ") ;
		content.append("[NL][TAB][TAB]").append("Component2( ) : Component() {}; ") ;
		content.append("[NL][TAB][TAB]").append("virtual void Action(){") ;
		content.append("[NL][TAB][TAB][TAB]").append("ActionComponent();") ;
		content.append("[NL][TAB][TAB]").append("}") ;
		content.append("[NL][TAB]").append("};") ;
		content.append("[NL]").append("int main(){") ;
		content.append("[NL][TAB]").append("IComponent *c = new Component2();") ;
		content.append("[NL][TAB]").append("c->Action();") ;
		content.append("[NL][TAB]").append("return 0;") ; 
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		question = new Question("Adapter Pattern", "Which design pattern is implemented below?[NL][NL]" + content.toString(), Niveau.SENIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Adaptor", Boolean.TRUE) ; 
		mapPropositions.put("Facade", Boolean.FALSE) ; 
		mapPropositions.put("Decorator", Boolean.FALSE) ; 
		mapPropositions.put("Singleton", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		question = new Question("smart pointer", "What does a smart pointer?", Niveau.SENIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("Manages circular references in a easy way.", Boolean.FALSE) ; 
		mapPropositions.put("Manages references on objects of different types.", Boolean.FALSE) ;
		mapPropositions.put("Automatically frees the object it points to when the object is no more referenced.", Boolean.TRUE) ; 
		mapPropositions.put("Cleans as a garbage collector the circular references.", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		content = new StringBuilder() ; 
		content.append("[code style=cpp]").append("[NL]") ; 
		content.append("#include <iostream>").append("") ;
		content.append("[NL]").append("#include <iterator>") ;
		content.append("[NL]").append("#include <set>") ;
		content.append("[NL]").append("#include <algorithm>") ;
		content.append("[NL]").append("int main() {") ;
		content.append("[NL][TAB]").append("using std::set;") ;
		content.append("[NL][NL][TAB]").append("typedef std::istream_iterator< int > In;") ;
		content.append("[NL][TAB]").append("typedef std::ostream_iterator< int > Out;") ; 
		content.append("[NL][NL][TAB]").append("set< int , std::greater< int > > res;") ;
		content.append("[NL][TAB]").append("copy( In( std::cin ) , In() , inserter( res , res.begin() ) );") ;
		content.append("[NL][TAB]").append("remove_copy( res.begin() , res.end(), Out( std::cout << std::hex , [DB] [DB] ) , 0 );") ; 
		content.append("[NL][TAB]").append("return 0;") ; 
		content.append("[NL]").append("}") ;
		content.append("[/code]") ;
		question = new Question("STL", "What's the output if we enter [DB]0 12 5 9 5[DB] for the following code?[NL][NL]" + content.toString(), Niveau.SENIOR) ; 
		mapPropositions = new LinkedHashMap <String , Boolean> () ;
		mapPropositions.put("12 9 5 0", Boolean.FALSE) ; 
		mapPropositions.put("c 9 5 0", Boolean.FALSE) ; 
		mapPropositions.put("c 9 5", Boolean.TRUE) ; 
		mapPropositions.put("c 9 5 5", Boolean.FALSE) ;
		mapPropositions.put("5 9 12", Boolean.FALSE) ; 
		mapPropositions.put("c 9 5 5 0", Boolean.FALSE) ;
		mapQuestions.put(question, mapPropositions) ;
		
		return mapQuestions ; 
	}

	private TestSheet fillAllQuestions (TestSheet abtractTest , Map <Question , Map <String , Boolean>> mapQuestions ) {
		List<Question> questions = new ArrayList<Question> ();
		for ( Map.Entry <Question , Map <String , Boolean>> entry : mapQuestions.entrySet()) {
			
			Question question = entry.getKey() ; 
			Set<PropositionReponse> listPropositions = new LinkedHashSet<PropositionReponse>() ; 
			
			for (Map.Entry<String , Boolean> entryProposition : entry.getValue().entrySet() ) {
				listPropositions.add(new PropositionReponse (question , entryProposition.getKey() , entryProposition.getValue() )) ; 
			}
			
			question.setTest(abtractTest) ; 
			question.setPropositionsReponses(listPropositions) ; 
			questions.add(question) ;
		}
		
		abtractTest.setQuestions(questions) ; 
        return abtractTest ; 
    }

	private Profil fillAdminProfil () {
        // creation de profil
        Profil admin = new Profil("DA SILVEIRA" , "Tata") ;
        admin.setLogin("admin") ; 
        admin.setPass("admin") ; 
        admin.setAdmin(Boolean.TRUE) ; 
        admin.setActive(Boolean.TRUE) ; 
        admin.setDateActivation(new Date()) ;
        admin.setEmail("admin@ossia-conseil.com"); // facultatif
        return admin ; 
    }
	
	private Profil fillCandidateProfil () {
        // creation de profil
        Profil admin = new Profil("profil" , "candidat") ;
        admin.setLogin("pc") ; 
        admin.setPass("pc") ; 
        admin.setAdmin(Boolean.FALSE) ; 
        admin.setActive(Boolean.TRUE) ; 
        admin.setDateActivation(new Date()) ;
        admin.setEmail("candidat@ossia-conseil.com"); // facultatif
        return admin ; 
    }
    
	@Test
	public void insertAllTests () {
		Profil admin = fillAdminProfil() ;
		admin = profilService.createProfil(admin, admin) ;
		
		Profil candidat = fillCandidateProfil() ;
		candidat = profilService.createProfil(candidat, admin) ;
		log.debug("identifiant du profil cr : "+candidat.getId()) ; 
		
		testSheetService.createTestSheet(createTestJava() , admin) ; 
		testSheetService.createTestSheet(createTestCsharp() , admin) ; 
		testSheetService.createTestSheet(createTestCplusplus() , admin) ; 
	}
}